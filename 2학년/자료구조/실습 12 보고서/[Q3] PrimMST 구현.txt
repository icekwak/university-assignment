(Edge class)
public class Edge {
	int adjvertex;	// 간선의 다른 쪽 끝 정점
	int weight;		// 간선의 가중치
	public Edge(int v, int wt) {
		adjvertex = v;
		weight = wt;
	}
}

------------------------------------------------------------------------
(PrimMST class)
import java.util.*;
public class PrimMST {
	int N; // 그래프 정점의 수
	List<Edge>[] graph;
	
	public PrimMST(List<Edge>[] adjList) { // 생성자
		N = adjList.length;
		graph = adjList;
	}
	
	public int[] mst(int s) { // Prim 알고리즘, s는 시작정점
		boolean[] visited = new boolean[N]; // 방문된 정점은 true로
		int[] D = new int[N];
		int[] previous = new int[N]; // 최소신장트리의 간선으로 확정될 때 간선의 다른 쪽 (트리의)끝 점
		for(int i = 0; i < N; i++) { // 초기화
			visited[i] = false;
			previous[i] = -1;
			D[i] = Integer.MAX_VALUE; // D[i]를 최댓값으로 초기화
		}
		previous[s] = 0; // 시작정점 s의 관련 정보 초기화
		D[s] = 0;
		
		for(int k = 0; k < N; k++) { // 방문안된 정점들의 D 원소들 중에서 최솟값 가진 정점 minVertex 찾기
			int minVertex = -1;
			int min = Integer.MAX_VALUE;
			for(int j = 0; j < N; j++) {
				if((!visited[j]) && (D[j] < min)) {
					min = D[j];
					minVertex = j;
				}
			}
			visited[minVertex] = true;
			for(Edge i : graph[minVertex]) { // minVertex에 인접한 각 정점의 D의 원소 갱신
				if(!visited[i.adjvertex]) {	 // 트리에 아직 포함 안된 정점이면
					int currentDist = D[i.adjvertex];
					int newDist = i.weight;
					if(newDist < currentDist) {
						D[i.adjvertex] = newDist; // minVertex와 연결된 정점들의 D 원소 갱신
						previous[i.adjvertex] = minVertex; // 트리 간선 추출을 위해
					}
				}
			}
		}
		return previous; // 최소신장트리 간선 정보 리턴
	}
	
	public void PreviousPrint(int[] previous) { // 최소신장트리 간선
		System.out.println("최소신장트리 간선 :");
		for(int i = 1; i < N; i++)
			System.out.printf("(%d,%d) ",i,previous[i]);
		System.out.println();
	}
	
	public int PreviousSum(int[] previous) { // 최소신장트리의 간선 가중치 합
		int hap = 0; // 가중치 합
		for(int i = 1; i < N; i++) {
			for(Edge e : graph[i]) {
				if(e.adjvertex == previous[i]) {
					hap += e.weight;
					break;
				}
			}
		}
		return hap;
	}
}

--------------------------------------------------------------------------------------------------------------
(PrimMSTtest class)
import java.util.*;
public class PrimMSTtest {
	public static void main(String[] arg) {
		int N = 7;
		List<Edge>[] adjList = new List[N];
		
		for(int i =0; i < N; i++)
			adjList[i] = new LinkedList<>();
		
		adjList[0].add(new Edge(1,9));	adjList[0].add(new Edge(2,10));
		
		adjList[1].add(new Edge(0,9));	adjList[1].add(new Edge(3,10));
		adjList[1].add(new Edge(4,5));	adjList[1].add(new Edge(6,3));
		
		adjList[2].add(new Edge(0,10));	adjList[2].add(new Edge(3,9));
		adjList[2].add(new Edge(4,7));	adjList[2].add(new Edge(5,2));
		
		adjList[3].add(new Edge(1,10));	adjList[3].add(new Edge(2,9));
		adjList[3].add(new Edge(5,4));	adjList[3].add(new Edge(6,8));
		
		adjList[4].add(new Edge(1,5));	adjList[4].add(new Edge(2,7));
		adjList[4].add(new Edge(6,1));
		
		adjList[5].add(new Edge(2,2));	adjList[5].add(new Edge(3,4));
		adjList[5].add(new Edge(6,6));
		
		adjList[6].add(new Edge(1,3));	adjList[6].add(new Edge(3,8));
		adjList[6].add(new Edge(4,1));	adjList[6].add(new Edge(5,6));
		
		PrimMST prim = new PrimMST(adjList);
		int[] previous = prim.mst(0); // 정점 0부터 시작한 previous
		prim.PreviousPrint(previous); // 최소신장트리 간선 출력
		System.out.println("최소신장트리의 간선 가중치 합 = " + prim.PreviousSum(previous));
	}
}