(Edge class)
public class Edge {
	int adjvertex; // 간선의 다른 쪽 정점
	
	public Edge(int v) { // 생성자
		adjvertex = v;
	}
}

-----------------------------------------------------------------------------
(TopologicalSort class)
import java.util.*;
public class TopologicalSort {
	int N;					 // 그래프의 정점 수
	boolean[] visited;		 // DFS 수행 중 방문여부 체크 용
	List<Edge>[] adjList; // 인접리스트 형태의 입력 그래프
	List<Edge> sequence;	 // 위상 정렬 순서를 담을 리스트
	
	public TopologicalSort(List<Edge>[] graph) { // 생성자
		N = graph.length;
		visited = new boolean[N];
		adjList = graph;
		sequence = new ArrayList<>();
	}
	
	public List<Edge> tsort(){	   // 위상정렬을 위한 DFS 수행
		for(int i =0; i < N; i++) {	
			if(!visited[i])
				dfs(i);
		}
		Collections.reverse(sequence); // sequence를 역순으로 만들기
		return sequence;
	}
	
	public void dfs(int i) {	  // DFS 수행
		visited[i] = true;
		for(Edge v : adjList[i]) { // i의 방문이 끝나고 앞으로 방문해야하는 각 정점 v에 대해
			if(!visited[v.adjvertex])
				dfs(v.adjvertex);
		}
		sequence.add(new Edge(i));		  // i에서 진출하는 간선이 더 이상 없으므로 i를 sequence에 추가
	}
}

-------------------------------------------------------------------------------------------------
(Kosaraju class)
import java.util.*;
public class Kosaraju {
	int N;					// 정점 수
	List<Edge>[] graph;		// 인접리스트 그래프
	List<Edge> sequence;	// 위상정렬
	List<Edge>[] revgraph;	// 역방향 그래프
	boolean[] visited;		// DFS 수행 중 방문여부 체크 용
	List<Integer> data;		// 강 연결 성분을 저장할 공간
	
	public Kosaraju(List<Edge>[] adjList) { // 생성자
		N = adjList.length;
		graph = adjList;
		revgraph = reverseGraph();
		sequence = tSort();
		visited = new boolean[N];
		data = new ArrayList<>();
		
		for(int i = 0; i < N; i++) 
			visited[i] = false; // 배열 초기화
			
		for(Edge e : sequence) { // 위상정렬 순으로 역방향 그래프 dfs
			for(int i = 0; i < N; i++) {
				if(e.adjvertex == i) {
					if(!visited[i])
						dfs(i);
				}
			}
		}
	}
	
	public List<Edge>[] reverseGraph(){ // 역방향 그래프
		revgraph = new List[N];
		for(int i = 0; i < N; i++)
			revgraph[i] = new LinkedList<>();
		
		for(int i = 0; i < N; i++) {
			for(Edge e : graph[i])
				revgraph[e.adjvertex].add(new Edge(i));
		}
		return revgraph;
	}
	
	public List<Edge> tSort(){ // 위상정렬
		TopologicalSort ts = new TopologicalSort(graph);
		sequence = ts.tsort();
		return sequence;
	}
	
	private void dfs(int i) { // 역방향 그래프에서 DFS 수행
		visited[i] = true;			  // 정점 i가 방문되어 visited[i]를 true로 만든다.
		data.add(i);				  // 정점 i가 방문되었을 때, data에 저장

		for(Edge e : revgraph[i]) {	  // 정점 i에 인접한 각 정점에 대해
			if(!visited[e.adjvertex]) // 정점  i에 인접한 정점이 방문 안되었으면 재귀호출
				dfs(e.adjvertex);	
		}
		if(!data.isEmpty())			// 강 연결 성분 data가 비어 있지 않을 때 
			System.out.print(data + " ");	// 강 연결 성분 출력
		data = new ArrayList<>();	// 다음 강 연결 성분 출력을 위한 초기화
	}	
}

--------------------------------------------------------------------------------------------
(Q5Test class)
import java.util.*;
public class Q5Test {
	public static void main(String[] args) {
		int N = 10;
		List<Edge>[] adjList = new List[N];
		
		for(int i = 0; i < N; i++)
			adjList[i] = new LinkedList<>();
		
		adjList[0].add(new Edge(1));	adjList[0].add(new Edge(3));
		adjList[1].add(new Edge(7));	adjList[2].add(new Edge(8));
		adjList[3].add(new Edge(5));	adjList[3].add(new Edge(6));
		adjList[4].add(new Edge(1));	adjList[5].add(new Edge(1));
		adjList[5].add(new Edge(4));	adjList[6].add(new Edge(0));
		adjList[7].add(new Edge(4));	adjList[8].add(new Edge(6));
		adjList[8].add(new Edge(7));	adjList[8].add(new Edge(9));
		adjList[9].add(new Edge(2));
		
		
		Kosaraju k = new Kosaraju(adjList);
	}
}