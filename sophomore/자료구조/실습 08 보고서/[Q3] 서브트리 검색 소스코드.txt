(Node class)
public class Node <Key extends Comparable <Key>> {
	private Key item;
	private Node<Key> left;
	private Node<Key> right;
	
	public Node(Key newItem, Node lt, Node rt) {
		item = newItem;
		left = lt;
		right = rt;
	}
	
	public Key getKey() {
		return item;
	}
	public void setKey(Key newItem) {
		item = newItem;
	}
	
	public Node<Key> getLeft(){
		return left;
	}
	public void setLeft(Node<Key> lt) {
		left = lt;
	}
	
	public Node<Key> getRight(){
		return right;
	}
	public void setRight(Node<Key> lr) {
		right = lr;
	}
}

------------------------------------------------------------------------------------------------------------
(BinaryTree class)
import java.util.*;
public class BinaryTree <Key extends Comparable <Key>> {
	private Node root;
	
	public BinaryTree() {
		root = null;
	}
	
	public Node getRoot() {
		return root;
	}
	public void setRoot(Node newRoot) {
		root = newRoot;
	}
	
	public boolean isEmpty() {
		return root == null;
	}
	
	public void preorder(Node n) { // 전위순회
		if(n != null) {
			System.out.print(n.getKey() + " "); // 노드n 방문
			preorder(n.getLeft()); // n의 왼쪽 서브트리 순회
			preorder(n.getRight()); // n의 오른쪽 서브트리 순회
		}
	}
	
	public void inorder(Node n) { // 중위순회
		if(n != null) {
			inorder(n.getLeft()); // n의 왼쪽 서브트리 순회
			System.out.print(n.getKey() + " "); // 노드n 방문
			inorder(n.getRight()); // n의 오른쪽 서브트리 순회
		}
	}
	
	public void postorder(Node n) { // 후위순회
		if(n != null) {
			postorder(n.getLeft()); // n의 왼쪽 서브트리 순회
			postorder(n.getRight()); // n의 오른쪽 서브트리 순회
			System.out.print(n.getKey() + " "); // 노드n 방문
		}
	}
	
	public void levelorder(Node root) { // 레벨순회
		Queue<Node> q = new LinkedList<Node>(); // 큐 자료구조 이용
		Node t;
		q.add(root); // 루트 노드 큐에 삽입
		while(!q.isEmpty()) {
			t = q.remove(); // 큐에서 가장 앞에 있는 노드 제거
			System.out.print(t.getKey() + " "); // 제거된 노드 출력(방문)
			if(t.getLeft() != null) // 제거된 왼쪽 자식이 null이 아니면
				q.add(t.getLeft()); // 큐에 왼쪽 자식 삽입
			if(t.getRight() != null) // 제거된 오른쪽 자식이 null이 아니면
				q.add(t.getRight()); // 큐에 오른쪽 자식 삽입
		}
	}
	
	public int size(Node n) { // n를 루트로하는 (서브)트리에 있는 노드 수
		if(n == null)
			return 0; // null이면 0리턴
		else
			return (1 + size(n.getLeft()) + size(n.getRight()));
	}
	
	public int height(Node n) { //n를 루트로하는 (서브)트리의 높이
		if(n == null)
			return 0; // null이면 0리턴
		else
			return (1 + Math.max(height(n.getLeft()), height(n.getRight())));
	}
	
	public static boolean isEqual(Node n, Node m) { // 두 트리의 동일성 검사
		if(n == null || m == null) // 둘 중에 하나라도 null이면
			return n == m; // 둘 다 null이면 true, 아니면 false
		if(n.getKey().compareTo(m.getKey()) != 0) // 둘 다 null이 아니면 item 비교
			return false;
		
		return (isEqual(n.getLeft(), m.getLeft()) && // item이 같으면 왼쪽 자식 재귀호출
				isEqual(n.getRight(), m.getRight())); // 오른쪽 자식 재귀호출
	}

	public LinkedList<Node> subTreeCompare(BinaryTree t){ // 동일한 서브트리 검사
		LinkedList<Node> list = new LinkedList<Node>(); // 서브 트리 루트 노드 list에 저장
		
		// 소스코드가 반복적이어서 따로 subtreeNode라는 함수를 밑에 만듬
		// 각각의 서브트리 노드들을 저장하는 list
		LinkedList<Node> dataA = subtreeNode(root);
		LinkedList<Node> dataB = subtreeNode(t.root);
		
		// 서브트리 루트 노드들의 동일성 검사
		for(int i = 0; i< dataA.size(); i++) {
			for(int j=0; j < dataB.size(); j++) {
				if(isEqual(dataA.get(i),dataB.get(j))) {
					list.add(dataA.get(i)); // 같은 서브트리가 있으면 list에 저장
					break;
				}
			}
		}
		return list;
	}
	public LinkedList<Node> subtreeNode(Node n){ // 서브트리의 각각 노드를 list에 저장
		Queue<Node> q = new LinkedList<Node>();
		LinkedList<Node> data = new LinkedList<Node>(); // 트리의 노드들을 저장할 data
		Node r;
		q.add(n);
		while(!q.isEmpty()) {
			r = q.remove();
			data.add(r); // data에 각 노드들 저장
			if(r.getLeft() != null) // 왼쪽
				q.add(r.getLeft());
			if(r.getRight() != null) //오른쪽
				q.add(r.getRight());
		}
		return data; // 각각 저장된 노드들의 data리턴
	}
}

---------------------------------------------------------------------------------------------------------------------------
(SubTreeCompareTest class)
import java.util.*;
public class SubTreeCompareTest {
	public static void main(String[] args) {
		// tA 트리 구성
		BinaryTree<Integer> tA = new BinaryTree<Integer>();
		Node<Integer> A800 = new Node<Integer>(800,null,null);
		Node<Integer> A400 = new Node<Integer>(400,A800,null);
		Node<Integer> A500 = new Node<Integer>(500,null,null);
		Node<Integer> A200 = new Node<Integer>(200,A400,A500);
		Node<Integer> A600 = new Node<Integer>(600,null,null);
		Node<Integer> A700 = new Node<Integer>(700,null,null);
		Node<Integer> A300 = new Node<Integer>(300,A600,A700);
		Node<Integer> A100 = new Node<Integer>(100,A200,A300);
		tA.setRoot(A100); // 루트노드 설정
				
		// tB 트리 구성
		BinaryTree<Integer> tB = new BinaryTree<Integer>();
		Node<Integer> B600 = new Node<Integer>(600,null,null);
		Node<Integer> B700 = new Node<Integer>(700,null,null);
		Node<Integer> B300 = new Node<Integer>(300,B600,B700);
		Node<Integer> B7 = new Node<Integer>(7,null,null);
		Node<Integer> B2 = new Node<Integer>(2,B300,B7);
		Node<Integer> B9 = new Node<Integer>(9,null,null);
		Node<Integer> B70 = new Node<Integer>(70,null,null);
		Node<Integer> B3 = new Node<Integer>(3,B9,B70);
		Node<Integer> B1 = new Node<Integer>(1,B2,B3);
		tB.setRoot(B1); // 루트노드 설정
		
		LinkedList<Node> list = tA.subTreeCompare(tB);
		BinaryTree<Integer> t = new BinaryTree<Integer>();
		for(int i=0; i < list.size(); i++) {
			System.out.println("Found a matching subtree " + (i+1) + ":");
			t.levelorder(list.get(i));
			System.out.println();
		}
	}
}